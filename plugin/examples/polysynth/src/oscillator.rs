//! Oscillator implementation.
//!
//! This is where all of the DSP math happens.

use std::f32::consts::{PI, TAU};

/// A very basic Square Wave oscillator.
///
/// This whole implementation is from https://www.martin-finke.de/articles/audio-plugins-008-synthesizing-waveforms/.
#[derive(Copy, Clone)]
pub struct SquareOscillator {
    /// The ratio between the frequency (in Hz) and the per-sample phase increment.
    /// This is only dependant on the sample rate.
    frequency_to_phase_increment_ratio: f32,
    /// The per-sample phase increment.
    phase_increment: f32,
    /// The current phase of this oscillator.
    current_phase: f32,
}

impl SquareOscillator {
    /// Initializes a new oscillator for a given sample rate.
    #[inline]
    pub fn new(sample_rate: f32) -> Self {
        Self {
            frequency_to_phase_increment_ratio: 2.0 * PI / sample_rate,
            phase_increment: 1.0,
            current_phase: 0.,
        }
    }

    /// Resets the oscillator. This simply sets its current phase back to 0.
    #[inline]
    pub fn reset(&mut self) {
        self.current_phase = 0.;
    }

    /// Sets the current frequency of this oscillator using a MIDI note number.
    ///
    /// For setting the frequency directly, see [`SquareOscillator::set_frequency`].
    #[inline]
    pub fn set_note_number(&mut self, new_note_number: u8) {
        self.set_frequency(440.0 * 2.0f32.powf((new_note_number as f32 - 69.0) / 12.0));
    }

    /// Sets the new frequency of this oscillator.
    ///
    /// The next samples generated by this oscillator will be at that frequency.
    #[inline]
    pub fn set_frequency(&mut self, new_frequency: f32) {
        self.phase_increment = new_frequency * self.frequency_to_phase_increment_ratio;
    }

    /// Adds the next values produced by this oscillator to the given buffer, at the given volume.
    ///
    /// The given volume should be in the `0..1` range.
    #[inline]
    pub fn add_next_samples_to_buffer(&mut self, buf: &mut [f32], volume: f32) {
        for value in buf {
            if self.current_phase <= PI {
                *value += volume;
            } else {
                *value -= volume;
            }

            self.current_phase += self.phase_increment;
            while self.current_phase > TAU {
                self.current_phase -= TAU;
            }
        }
    }
}
